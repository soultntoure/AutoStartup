```json
{
  "repo_name": "zenith-journal",
  "description": "A gamified daily journaling app with AI reflection prompts and mood tracking to make self-reflection a rewarding habit.",
  "files": [
    {
      "path": ".gitignore",
      "content": "# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\npnpm-debug.log*\nlerna-debug.log*\n\n# Node\nnode_modules\ndist\ndist-ssr\n*.local\n\n# Environment variables\n.env\n.env.local\n.env.development.local\n.env.test.local\n.env.production.local\n\n# IDEs\n.idea/\n.vscode/\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw?\n\n# Expo\n.expo/\n*.jks\n*.p8\n*.p12\n*.key\n*.mobileprovision\n*.orig\n\n# macOS\n.DS_Store\n"
    },
    {
      "path": "package.json",
      "content": "{\n  \"name\": \"zenith-journal-monorepo\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev:api\": \"pnpm --filter api dev\",\n    \"dev:mobile\": \"pnpm --filter mobile start\",\n    \"build:api\": \"pnpm --filter api build\",\n    \"build:mobile\": \"pnpm --filter mobile build\"\n  },\n  \"devDependencies\": {\n    \"typescript\": \"^5.3.3\"\n  }\n}\n"
    },
    {
      "path": "pnpm-workspace.yaml",
      "content": "packages:\n  - 'apps/*'\n  - 'packages/*'\n"
    },
    {
      "path": "README.md",
      "content": "# Zenith Journal\n\nZenith is a gamified daily journaling app designed to make self-reflection a rewarding and consistent habit. It combines AI-powered prompts, detailed mood tracking, and engaging game mechanics to help you understand your mind and build a positive routine.\n\n## ✨ Features\n\n*   **AI-Powered Prompts:** Get intelligent, empathetic prompts to guide your reflections.\n*   **Mood Tracking:** Log your mood and activities to discover patterns and insights.\n*   **Gamified Experience:** Earn points, unlock achievements, and watch your personal 'Zenith' grow as you build your journaling streak.\n*   **Data-Driven Insights:** Visualize your progress and mood trends over time with beautiful charts.\n\n## 🛠️ Tech Stack\n\nThis project is a monorepo managed with `pnpm workspaces`.\n\n| Area         | Technology                                      |\n| :----------- | :---------------------------------------------- |\n| **Mobile App** | [React Native](https://reactnative.dev/) + [Expo](https://expo.dev/)                 |\n| **Backend**    | [Node.js](https://nodejs.org/) + [Express.js](https://expressjs.com/) + [TypeScript](https://www.typescriptlang.org/) |\n| **Database**   | [MongoDB](https://www.mongodb.com/) + [Mongoose](https://mongoosejs.com/)                  |\n| **AI**         | [OpenAI API](https://beta.openai.com/docs/)     |\n\n## 🚀 Getting Started\n\nFollow these instructions to get the project up and running on your local machine for development and testing purposes.\n\n### Prerequisites\n\n- [Node.js](https://nodejs.org/en/) (v18 or later)\n- [pnpm](https://pnpm.io/installation)\n- [Expo Go](https://expo.dev/go) app on your mobile device or an emulator setup.\n\n### Installation\n\n1.  **Clone the repository:**\n    ```bash\n    git clone https://github.com/your-username/zenith-journal.git\n    cd zenith-journal\n    ```\n\n2.  **Install dependencies:**\n    *pnpm will automatically install dependencies for all workspaces (api, mobile, etc.).*\n    ```bash\n    pnpm install\n    ```\n\n3.  **Set up environment variables:**\n\n    *   **For the API:**\n        Create a `.env` file in `apps/api/` by copying the example file:\n        ```bash\n        cp apps/api/.env.example apps/api/.env\n        ```\n        Then, fill in the required values in `apps/api/.env`:\n        ```\n        # Server Configuration\n        PORT=8000\n\n        # MongoDB Connection\n        MONGO_URI=your_mongodb_connection_string\n\n        # JWT Configuration\n        JWT_SECRET=your_super_secret_jwt_key\n        JWT_EXPIRES_IN=1d\n\n        # OpenAI API Key\n        OPENAI_API_KEY=your_openai_api_key\n        ```\n\n    *   **For the Mobile App:**\n        The mobile app will get its API URL from an environment variable. Create a `.env` file in `apps/mobile/`:\n        ```bash\n        touch apps/mobile/.env\n        ```\n        Add the following variable, pointing to your local API server:\n        ```\n        EXPO_PUBLIC_API_URL=http://localhost:8000/api/v1\n        ```\n\n4.  **Run the project:**\n\n    *   **Run the Backend API:**\n        ```bash\n        pnpm --filter api dev\n        ```\n        The API server should now be running on `http://localhost:8000`.\n\n    *   **Run the Mobile App:**\n        In a new terminal window:\n        ```bash\n        pnpm --filter mobile start\n        ```\n        This will start the Expo development server. You can now scan the QR code with the Expo Go app on your phone or run it in a simulator.\n"
    },
    {
      "path": "tsconfig.json",
      "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ESNext\",\n    \"module\": \"ESNext\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"moduleResolution\": \"node\"\n  },\n  \"exclude\": [\"node_modules\"]\n}\n"
    },
    {
      "path": "apps/api/package.json",
      "content": "{\n  \"name\": \"api\",\n  \"version\": \"1.0.0\",\n  \"main\": \"dist/server.js\",\n  \"scripts\": {\n    \"dev\": \"ts-node-dev --respawn --transpile-only src/server.ts\",\n    \"build\": \"tsc\",\n    \"start\": \"node dist/server.js\"\n  },\n  \"dependencies\": {\n    \"bcryptjs\": \"^2.4.3\",\n    \"cors\": \"^2.8.5\",\n    \"dotenv\": \"^16.3.1\",\n    \"express\": \"^4.18.2\",\n    \"jsonwebtoken\": \"^9.0.2\",\n    \"mongoose\": \"^8.0.3\",\n    \"openai\": \"^4.24.1\",\n    \"@zenith/types\": \"workspace:*\"\n  },\n  \"devDependencies\": {\n    \"@types/bcryptjs\": \"^2.4.6\",\n    \"@types/cors\": \"^2.8.17\",\n    \"@types/express\": \"^4.17.21\",\n    \"@types/jsonwebtoken\": \"^9.0.5\",\n    \"@types/node\": \"^20.10.5\",\n    \"ts-node-dev\": \"^2.0.0\",\n    \"typescript\": \"^5.3.3\"\n  }\n}\n"
    },
    {
      "path": "apps/api/tsconfig.json",
      "content": "{\n  \"extends\": \"../../tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"]\n    }\n  },\n  \"include\": [\"src/**/*.ts\"],\n  \"exclude\": [\"node_modules\"]\n}\n"
    },
    {
      "path": "apps/api/.env.example",
      "content": "# Server Configuration\nPORT=8000\n\n# MongoDB Connection\nMONGO_URI=your_mongodb_connection_string_here\n\n# JWT Configuration\nJWT_SECRET=your_super_secret_jwt_key_here\nJWT_EXPIRES_IN=1d\n\n# OpenAI API Key\nOPENAI_API_KEY=your_openai_api_key_here\n"
    },
    {
      "path": "apps/api/src/server.ts",
      "content": "import app from './app';\nimport connectDB from './config/db';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nconst PORT = process.env.PORT || 8000;\n\nconnectDB();\n\napp.listen(PORT, () => {\n  console.log(`🚀 Server running on http://localhost:${PORT}`);\n});\n"
    },
    {
      "path": "apps/api/src/app.ts",
      "content": "import express, { Application, Request, Response } from 'express';\nimport cors from 'cors';\nimport authRoutes from './api/v1/routes/auth.routes';\nimport journalRoutes from './api/v1/routes/journal.routes';\nimport userRoutes from './api/v1/routes/user.routes';\n\nconst app: Application = express();\n\n// Middlewares\napp.use(cors());\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n// API V1 Routes\napp.use('/api/v1/auth', authRoutes);\napp.use('/api/v1/journal', journalRoutes);\napp.use('/api/v1/user', userRoutes);\n\n// Health Check\napp.get('/health', (req: Request, res: Response) => {\n  res.status(200).json({ status: 'UP' });\n});\n\nexport default app;\n"
    },
    {
      "path": "apps/api/src/config/db.ts",
      "content": "import mongoose from 'mongoose';\n\nconst connectDB = async () => {\n  try {\n    const mongoUri = process.env.MONGO_URI;\n    if (!mongoUri) {\n      console.error('MONGO_URI is not defined in the environment variables.');\n      process.exit(1);\n    }\n    await mongoose.connect(mongoUri);\n    console.log('MongoDB connected successfully.');\n  } catch (error) {\n    console.error('MongoDB connection failed:', error);\n    process.exit(1);\n  }\n};\n\nexport default connectDB;\n"
    },
    {
      "path": "apps/api/src/api/v1/routes/auth.routes.ts",
      "content": "import { Router } from 'express';\nimport { register, login } from '../controllers/auth.controller';\n\nconst router = Router();\n\nrouter.post('/register', register);\nrouter.post('/login', login);\n\nexport default router;\n"
    },
    {
      "path": "apps/api/src/api/v1/routes/journal.routes.ts",
      "content": "import { Router } from 'express';\nimport { createEntry, getEntries, getEntryById, deleteEntry, getAIPrompt } from '../controllers/journal.controller';\nimport { protect } from '../middlewares/auth.middleware';\n\nconst router = Router();\n\nrouter.use(protect); // Protect all journal routes\n\nrouter.route('/')\n  .post(createEntry)\n  .get(getEntries);\n\nrouter.route('/prompt').get(getAIPrompt);\n\nrouter.route('/:id')\n  .get(getEntryById)\n  .delete(deleteEntry);\n\nexport default router;\n"
    },
    {
      "path": "apps/api/src/api/v1/routes/user.routes.ts",
      "content": "import { Router } from 'express';\nimport { getMe } from '../controllers/user.controller';\nimport { protect } from '../middlewares/auth.middleware';\n\nconst router = Router();\n\nrouter.use(protect);\n\nrouter.get('/me', getMe);\n\nexport default router;\n"
    },
    {
      "path": "apps/api/src/api/v1/controllers/auth.controller.ts",
      "content": "import { Request, Response } from 'express';\nimport User from '../models/User';\nimport jwt from 'jsonwebtoken';\n\nconst generateToken = (id: string) => {\n  const secret = process.env.JWT_SECRET;\n  if (!secret) throw new Error('JWT_SECRET not found');\n  return jwt.sign({ id }, secret, {\n    expiresIn: process.env.JWT_EXPIRES_IN || '1d',\n  });\n};\n\nexport const register = async (req: Request, res: Response) => {\n  try {\n    const { email, password } = req.body;\n    if (!email || !password) {\n      return res.status(400).json({ message: 'Please provide email and password' });\n    }\n\n    const userExists = await User.findOne({ email });\n    if (userExists) {\n      return res.status(400).json({ message: 'User already exists' });\n    }\n\n    const user = await User.create({ email, password });\n    const token = generateToken(user._id.toString());\n\n    res.status(201).json({ token, email: user.email });\n  } catch (error) {\n    res.status(500).json({ message: 'Server error', error });\n  }\n};\n\nexport const login = async (req: Request, res: Response) => {\n  try {\n    const { email, password } = req.body;\n    const user = await User.findOne({ email });\n\n    if (user && (await user.matchPassword(password))) {\n      const token = generateToken(user._id.toString());\n      res.status(200).json({ token, email: user.email });\n    } else {\n      res.status(401).json({ message: 'Invalid credentials' });\n    }\n  } catch (error) {\n    res.status(500).json({ message: 'Server error', error });\n  }\n};\n"
    },
    {
      "path": "apps/api/src/api/v1/controllers/journal.controller.ts",
      "content": "import { Request, Response } from 'express';\nimport JournalEntry from '../models/JournalEntry';\nimport { getPrompt } from '../services/ai.service';\nimport { AuthenticatedRequest } from '../middlewares/auth.middleware';\n\n// @desc    Get an AI-generated prompt\n// @route   GET /api/v1/journal/prompt\n// @access  Private\nexport const getAIPrompt = async (req: Request, res: Response) => {\n  try {\n    const prompt = await getPrompt();\n    res.status(200).json({ prompt });\n  } catch (error) {\n    res.status(500).json({ message: 'Failed to get AI prompt', error });\n  }\n};\n\n// @desc    Create a new journal entry\n// @route   POST /api/v1/journal\n// @access  Private\nexport const createEntry = async (req: AuthenticatedRequest, res: Response) => {\n  try {\n    const { content, mood, tags } = req.body;\n    const entry = await JournalEntry.create({\n      user: req.user?._id,\n      content,\n      mood,\n      tags\n    });\n    res.status(201).json(entry);\n  } catch (error) {\n    res.status(500).json({ message: 'Server error', error });\n  }\n};\n\n// @desc    Get all journal entries for a user\n// @route   GET /api/v1/journal\n// @access  Private\nexport const getEntries = async (req: AuthenticatedRequest, res: Response) => {\n  try {\n    const entries = await JournalEntry.find({ user: req.user?._id }).sort({ createdAt: -1 });\n    res.status(200).json(entries);\n  } catch (error) {\n    res.status(500).json({ message: 'Server error', error });\n  }\n};\n\n// @desc    Get a single journal entry\n// @route   GET /api/v1/journal/:id\n// @access  Private\nexport const getEntryById = async (req: AuthenticatedRequest, res: Response) => {\n  try {\n    const entry = await JournalEntry.findById(req.params.id);\n    if (!entry || entry.user.toString() !== req.user?._id.toString()) {\n      return res.status(404).json({ message: 'Entry not found' });\n    }\n    res.status(200).json(entry);\n  } catch (error) {\n    res.status(500).json({ message: 'Server error', error });\n  }\n};\n\n// @desc    Delete a journal entry\n// @route   DELETE /api/v1/journal/:id\n// @access  Private\nexport const deleteEntry = async (req: AuthenticatedRequest, res: Response) => {\n  try {\n    const entry = await JournalEntry.findById(req.params.id);\n    if (!entry || entry.user.toString() !== req.user?._id.toString()) {\n      return res.status(404).json({ message: 'Entry not found' });\n    }\n    await entry.deleteOne();\n    res.status(200).json({ message: 'Entry removed' });\n  } catch (error) {\n    res.status(500).json({ message: 'Server error', error });\n  }\n};\n"
    },
    {
      "path": "apps/api/src/api/v1/controllers/user.controller.ts",
      "content": "import { Response } from 'express';\nimport { AuthenticatedRequest } from '../middlewares/auth.middleware';\nimport User from '../models/User';\n\n// @desc    Get user profile\n// @route   GET /api/v1/user/me\n// @access  Private\nexport const getMe = async (req: AuthenticatedRequest, res: Response) => {\n  try {\n    // The user object is attached to the request by the `protect` middleware\n    const user = await User.findById(req.user?._id).select('-password');\n    if (!user) {\n      return res.status(404).json({ message: 'User not found' });\n    }\n    res.status(200).json(user);\n  } catch (error) {\n    res.status(500).json({ message: 'Server Error' });\n  }\n};\n"
    },
    {
      "path": "apps/api/src/api/v1/models/JournalEntry.ts",
      "content": "import { Schema, model, Document, Types } from 'mongoose';\nimport { IJournalEntry } from '@zenith/types/journal';\n\ninterface JournalEntryDocument extends IJournalEntry, Document {\n  _id: Types.ObjectId;\n  user: Types.ObjectId;\n}\n\nconst JournalEntrySchema = new Schema<JournalEntryDocument>(\n  {\n    user: {\n      type: Schema.Types.ObjectId,\n      required: true,\n      ref: 'User',\n    },\n    content: {\n      type: String,\n      required: true,\n    },\n    mood: {\n      type: String,\n      required: true,\n      enum: ['happy', 'sad', 'neutral', 'excited', 'anxious'],\n    },\n    tags: {\n      type: [String],\n      default: [],\n    },\n  },\n  { timestamps: true }\n);\n\nexport default model<JournalEntryDocument>('JournalEntry', JournalEntrySchema);\n"
    },
    {
      "path": "apps/api/src/api/v1/models/User.ts",
      "content": "import { Schema, model, Document } from 'mongoose';\nimport bcrypt from 'bcryptjs';\n\n// NOTE: We do not import shared types for the User model on the backend\n// because it contains sensitive data (password) that should never leave the API.\ninterface UserDocument extends Document {\n  email: string;\n  password?: string;\n  matchPassword(enteredPass: string): Promise<boolean>;\n}\n\nconst UserSchema = new Schema<UserDocument>(\n  {\n    email: {\n      type: String,\n      required: true,\n      unique: true,\n      lowercase: true,\n    },\n    password: {\n      type: String,\n      required: true,\n    },\n  },\n  { timestamps: true }\n);\n\n// Encrypt password using bcrypt\nUserSchema.pre('save', async function (next) {\n  if (!this.isModified('password') || !this.password) {\n    return next();\n  }\n  const salt = await bcrypt.genSalt(10);\n  this.password = await bcrypt.hash(this.password, salt);\n  next();\n});\n\n// Match user entered password to hashed password in database\nUserSchema.methods.matchPassword = async function (enteredPassword) {\n  return await bcrypt.compare(enteredPassword, this.password);\n};\n\nexport default model<UserDocument>('User', UserSchema);\n"
    },
    {
      "path": "apps/api/src/api/v1/middlewares/auth.middleware.ts",
      "content": "import { Request, Response, NextFunction } from 'express';\nimport jwt from 'jsonwebtoken';\nimport User from '../models/User';\n\nexport interface AuthenticatedRequest extends Request {\n  user?: { _id: string; email: string };\n}\n\nexport const protect = async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {\n  let token;\n  const authHeader = req.headers.authorization;\n\n  if (authHeader && authHeader.startsWith('Bearer')) {\n    try {\n      token = authHeader.split(' ')[1];\n      const decoded = jwt.verify(token, process.env.JWT_SECRET!) as { id: string };\n      \n      // Attach user to the request object\n      const user = await User.findById(decoded.id).select('-password');\n      if (!user) {\n        return res.status(401).json({ message: 'Not authorized, user not found' });\n      }\n      req.user = user;\n      next();\n    } catch (error) {\n      console.error(error);\n      res.status(401).json({ message: 'Not authorized, token failed' });\n    }\n  }\n\n  if (!token) {\n    res.status(401).json({ message: 'Not authorized, no token' });\n  }\n};\n"
    },
    {
      "path": "apps/api/src/api/v1/services/ai.service.ts",
      "content": "import OpenAI from 'openai';\n\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n});\n\nexport const getPrompt = async (): Promise<string> => {\n  try {\n    const completion = await openai.chat.completions.create({\n      model: 'gpt-4o',\n      messages: [\n        {\n          role: 'system',\n          content: 'You are an empathetic and insightful journaling assistant. Provide a single, concise, and thought-provoking question to help a user reflect on their day. Do not include any conversational filler. For example: `What was the most challenging part of your day, and how did you navigate it?` or `Describe a moment today that made you smile.`',\n        },\n        {\n          role: 'user',\n          content: 'Give me a journaling prompt.'\n        }\n      ],\n      max_tokens: 50,\n      temperature: 0.8,\n    });\n\n    const prompt = completion.choices[0]?.message?.content?.trim();\n    if (!prompt) {\n        throw new Error('AI did not return a valid prompt.');\n    }\n    \n    return prompt;\n\n  } catch (error) {\n    console.error('Error fetching prompt from OpenAI:', error);\n    // Provide a fallback prompt in case of API failure\n    const fallbackPrompts = [\n      'What are you most grateful for today?',\n      'Describe a small victory you had today.',\n      'What is something that has been on your mind lately?'\n    ];\n    return fallbackPrompts[Math.floor(Math.random() * fallbackPrompts.length)];\n  }\n};\n"
    },
    {
      "path": "apps/mobile/package.json",
      "content": "{\n  \"name\": \"mobile\",\n  \"version\": \"1.0.0\",\n  \"main\": \"expo-router/entry\",\n  \"scripts\": {\n    \"start\": \"expo start\",\n    \"android\": \"expo start --android\",\n    \"ios\": \"expo start --ios\",\n    \"web\": \"expo start --web\",\n    \"build\": \"eas build\"\n  },\n  \"dependencies\": {\n    \"@zenith/types\": \"workspace:*\",\n    \"expo\": \"~51.0.8\",\n    \"expo-constants\": \"~16.0.1\",\n    \"expo-linking\": \"~6.3.1\",\n    \"expo-router\": \"~3.5.14\",\n    \"expo-status-bar\": \"~1.12.1\",\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\",\n    \"react-native\": \"0.74.1\",\n    \"react-native-safe-area-context\": \"4.10.1\",\n    \"react-native-screens\": \"~3.31.1\",\n    \"react-native-web\": \"~0.19.10\"\n  },\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.20.0\",\n    \"@types/react\": \"~18.2.45\",\n    \"typescript\": \"^5.3.3\"\n  },\n  \"private\": true\n}\n"
    },
    {
      "path": "apps/mobile/tsconfig.json",
      "content": "{\n  \"extends\": \"expo/tsconfig.base\",\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"paths\": {\n      \"@/*\": [\"./*\"]\n    }\n  },\n  \"include\": [\n    \"**/*.ts\",\n    \"**/*.tsx\",\n    \".expo/types/**/*.ts\",\n    \"expo-env.d.ts\"\n  ]\n}\n"
    },
    {
      "path": "apps/mobile/app.json",
      "content": "{\n  \"expo\": {\n    \"name\": \"Zenith Journal\",\n    \"slug\": \"zenith-journal\",\n    \"version\": \"1.0.0\",\n    \"orientation\": \"portrait\",\n    \"icon\": \"./assets/icon.png\",\n    \"scheme\": \"zenithjournal\",\n    \"userInterfaceStyle\": \"light\",\n    \"splash\": {\n      \"image\": \"./assets/splash.png\",\n      \"resizeMode\": \"contain\",\n      \"backgroundColor\": \"#ffffff\"\n    },\n    \"assetBundlePatterns\": [\n      \"**/*\"\n    ],\n    \"ios\": {\n      \"supportsTablet\": true,\n      \"bundleIdentifier\": \"com.zenith.journal\"\n    },\n    \"android\": {\n      \"adaptiveIcon\": {\n        \"foregroundImage\": \"./assets/adaptive-icon.png\",\n        \"backgroundColor\": \"#ffffff\"\n      },\n      \"package\": \"com.zenith.journal\"\n    },\n    \"web\": {\n      \"favicon\": \"./assets/favicon.png\"\n    },\n    \"plugins\": [\n      \"expo-router\"\n    ],\n    \"extra\": {\n      \"router\": {\n        \"origin\": false\n      },\n      \"eas\": {\n        \"projectId\": \"your-eas-project-id-here\"\n      }\n    }\n  }\n}\n"
    },
    {
      "path": "apps/mobile/app/index.tsx",
      "content": "import React from 'react';\nimport { ActivityIndicator, View } from 'react-native';\nimport { Redirect } from 'expo-router';\n\n// This is a placeholder for authentication logic.\n// In a real app, you would check for a stored token here.\nconst useAuth = () => {\n  // For now, we assume the user is not authenticated.\n  // Set to true to simulate being logged in.\n  const isAuthenticated = false;\n  const isLoading = false; // Set to true to show loading indicator\n  return { isAuthenticated, isLoading };\n};\n\nexport default function Index() {\n  const { isAuthenticated, isLoading } = useAuth();\n\n  if (isLoading) {\n    return (\n      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n        <ActivityIndicator size=\"large\" />\n      </View>\n    );\n  }\n\n  if (!isAuthenticated) {\n    return <Redirect href=\"/auth/login\" />;\n  }\n\n  return <Redirect href=\"/(tabs)/journal\" />;\n}\n"
    },
    {
      "path": "apps/mobile/app/_layout.tsx",
      "content": "import { Slot, SplashScreen } from 'expo-router';\nimport { useEffect } from 'react';\n\n// Prevent the splash screen from auto-hiding before asset loading is complete.\nSplashScreen.preventAutoHideAsync();\n\nexport default function RootLayout() {\n  // In a real app, you'd load fonts, assets, and check auth state here.\n  // For now, we just hide the splash screen after a short delay.\n  useEffect(() => {\n    // Pretend to load something\n    setTimeout(() => {\n      SplashScreen.hideAsync();\n    }, 1000);\n  }, []);\n\n  return (\n    // The Slot component renders the current child route.\n    // Here you could wrap your app in providers (e.g., for state management, theming).\n    <Slot />\n  );\n}\n"
    },
    {
      "path": "apps/mobile/app/(tabs)/_layout.tsx",
      "content": "import React from 'react';\nimport { Tabs } from 'expo-router';\nimport { Ionicons } from '@expo/vector-icons'; // Assuming you have this or similar icon pack\n\nexport default function TabLayout() {\n  return (\n    <Tabs\n      screenOptions={({ route }) => ({\n        tabBarIcon: ({ focused, color, size }) => {\n          let iconName: React.ComponentProps<typeof Ionicons>['name'] = 'alert-circle';\n\n          if (route.name === 'journal') {\n            iconName = focused ? 'journal' : 'journal-outline';\n          } else if (route.name === 'progress') {\n            iconName = focused ? 'stats-chart' : 'stats-chart-outline';\n          } else if (route.name === 'settings') {\n            iconName = focused ? 'settings' : 'settings-outline';\n          }\n\n          return <Ionicons name={iconName} size={size} color={color} />;\n        },\n        tabBarActiveTintColor: 'blue',\n        tabBarInactiveTintColor: 'gray',\n      })}\n    >\n      <Tabs.Screen name=\"journal\" options={{ title: 'Journal' }} />\n      <Tabs.Screen name=\"progress\" options={{ title: 'Progress' }} />\n      <Tabs.Screen name=\"settings\" options={{ title: 'Settings' }} />\n    </Tabs>\n  );\n}\n"
    },
    {
      "path": "apps/mobile/app/(tabs)/journal.tsx",
      "content": "import React, { useState } from 'react';\nimport { View, Text, TextInput, Button, StyleSheet, ActivityIndicator } from 'react-native';\n\nexport default function JournalScreen() {\n  const [prompt, setPrompt] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n  const [entry, setEntry] = useState('');\n\n  const fetchPrompt = () => {\n    setIsLoading(true);\n    // In a real app, you would call your API service here.\n    // e.g., `api.getAIPrompt().then(setPrompt)`\n    setTimeout(() => {\n      setPrompt('What was the highlight of your day?');\n      setIsLoading(false);\n    }, 1000);\n  };\n\n  return (\n    <View style={styles.container}>\n      <Text style={styles.title}>New Entry</Text>\n      \n      <View style={styles.promptContainer}>\n        <Text style={styles.promptText}>{prompt || 'Click below for a new prompt!'}</Text>\n        <Button title={isLoading ? 'Getting prompt...' : 'Get AI Prompt'} onPress={fetchPrompt} disabled={isLoading} />\n        {isLoading && <ActivityIndicator style={{ marginTop: 10 }}/>}\n      </View>\n\n      <TextInput\n        style={styles.input}\n        placeholder=\"Start writing...\"\n        multiline\n        value={entry}\n        onChangeText={setEntry}\n      />\n\n      <Button title=\"Save Entry\" onPress={() => alert('Entry Saved!')} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    padding: 20,\n    backgroundColor: '#f5f5f5',\n  },\n  title: {\n    fontSize: 24,\n    fontWeight: 'bold',\n    marginBottom: 20,\n  },\n  promptContainer: {\n    backgroundColor: '#eef',\n    padding: 15,\n    borderRadius: 8,\n    marginBottom: 20,\n  },\n  promptText: {\n    fontSize: 16,\n    fontStyle: 'italic',\n    textAlign: 'center',\n    marginBottom: 10,\n  },\n  input: {\n    flex: 1,\n    backgroundColor: 'white',\n    padding: 15,\n    fontSize: 16,\n    borderRadius: 8,\n    textAlignVertical: 'top',\n    marginBottom: 20,\n  },\n});\n"
    },
    {
      "path": "apps/mobile/app/(tabs)/progress.tsx",
      "content": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\n\nexport default function ProgressScreen() {\n  return (\n    <View style={styles.container}>\n      <Text style={styles.title}>Your Progress</Text>\n      <Text style={styles.placeholder}>Mood charts and gamification stats will be shown here.</Text>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    padding: 20,\n  },\n  title: {\n    fontSize: 22,\n    fontWeight: 'bold',\n    marginBottom: 16,\n  },\n  placeholder: {\n    fontSize: 16,\n    color: 'gray',\n    textAlign: 'center',\n  },\n});\n"
    },
    {
      "path": "apps/mobile/app/(tabs)/settings.tsx",
      "content": "import React from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\nimport { useRouter } from 'expo-router';\n\nexport default function SettingsScreen() {\n  const router = useRouter();\n\n  const handleLogout = () => {\n    // In a real app, you'd clear the auth token and then redirect.\n    router.replace('/auth/login');\n  };\n\n  return (\n    <View style={styles.container}>\n      <Text style={styles.title}>Settings</Text>\n      <Text style={styles.item}>Account</Text>\n      <Text style={styles.item}>Notifications</Text>\n      <Text style={styles.item}>Appearance</Text>\n      <View style={styles.logoutButton}>\n        <Button title=\"Logout\" onPress={handleLogout} color=\"red\" />\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    paddingTop: 20,\n  },\n  title: {\n    fontSize: 22,\n    fontWeight: 'bold',\n    marginBottom: 20,\n    paddingHorizontal: 16,\n  },\n  item: {\n    fontSize: 18,\n    padding: 16,\n    borderBottomWidth: 1,\n    borderBottomColor: '#ccc',\n  },\n  logoutButton: {\n    marginTop: 40,\n    marginHorizontal: 16,\n  }\n});\n"
    },
    {
      "path": "apps/mobile/app/auth/login.tsx",
      "content": "import React, { useState } from 'react';\nimport { View, Text, TextInput, Button, StyleSheet, Pressable } from 'react-native';\nimport { useRouter, Link } from 'expo-router';\n\nexport default function LoginScreen() {\n  const router = useRouter();\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n\n  const handleLogin = () => {\n    // Dummy login logic\n    console.log('Logging in with:', email, password);\n    // On successful login, you would save the token and redirect.\n    router.replace('/(tabs)/journal');\n  };\n\n  return (\n    <View style={styles.container}>\n      <Text style={styles.title}>Welcome Back!</Text>\n      <TextInput\n        style={styles.input}\n        placeholder=\"Email\"\n        value={email}\n        onChangeText={setEmail}\n        keyboardType=\"email-address\"\n        autoCapitalize=\"none\"\n      />\n      <TextInput\n        style={styles.input}\n        placeholder=\"Password\"\n        value={password}\n        onChangeText={setPassword}\n        secureTextEntry\n      />\n      <Button title=\"Login\" onPress={handleLogin} />\n      <Link href=\"/auth/signup\" asChild>\n        <Pressable style={styles.linkContainer}>\n          <Text style={styles.linkText}>Don't have an account? Sign Up</Text>\n        </Pressable>\n      </Link>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    justifyContent: 'center',\n    padding: 20,\n  },\n  title: {\n    fontSize: 24,\n    fontWeight: 'bold',\n    textAlign: 'center',\n    marginBottom: 24,\n  },\n  input: {\n    height: 40,\n    borderColor: 'gray',\n    borderWidth: 1,\n    marginBottom: 12,\n    padding: 10,\n    borderRadius: 5,\n  },\n  linkContainer: {\n    marginTop: 15,\n  },\n  linkText: {\n    color: 'blue',\n    textAlign: 'center',\n  }\n});\n"
    },
    {
      "path": "apps/mobile/app/auth/signup.tsx",
      "content": "import React, { useState } from 'react';\nimport { View, Text, TextInput, Button, StyleSheet, Pressable } from 'react-native';\nimport { useRouter, Link } from 'expo-router';\n\nexport default function SignUpScreen() {\n  const router = useRouter();\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n\n  const handleSignUp = () => {\n    // Dummy sign-up logic\n    console.log('Signing up with:', email, password);\n    // On successful sign-up, you might automatically log them in and redirect.\n    router.replace('/(tabs)/journal');\n  };\n\n  return (\n    <View style={styles.container}>\n      <Text style={styles.title}>Create Account</Text>\n      <TextInput\n        style={styles.input}\n        placeholder=\"Email\"\n        value={email}\n        onChangeText={setEmail}\n        keyboardType=\"email-address\"\n        autoCapitalize=\"none\"\n      />\n      <TextInput\n        style={styles.input}\n        placeholder=\"Password\"\n        value={password}\n        onChangeText={setPassword}\n        secureTextEntry\n      />\n      <Button title=\"Sign Up\" onPress={handleSignUp} />\n       <Link href=\"/auth/login\" asChild>\n        <Pressable style={styles.linkContainer}>\n          <Text style={styles.linkText}>Already have an account? Login</Text>\n        </Pressable>\n      </Link>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    justifyContent: 'center',\n    padding: 20,\n  },\n  title: {\n    fontSize: 24,\n    fontWeight: 'bold',\n    textAlign: 'center',\n    marginBottom: 24,\n  },\n  input: {\n    height: 40,\n    borderColor: 'gray',\n    borderWidth: 1,\n    marginBottom: 12,\n    padding: 10,\n    borderRadius: 5,\n  },\n  linkContainer: {\n    marginTop: 15,\n  },\n  linkText: {\n    color: 'blue',\n    textAlign: 'center',\n  }\n});\n"
    },
    {
      "path": "packages/types/package.json",
      "content": "{\n  \"name\": \"@zenith/types\",\n  \"version\": \"1.0.0\",\n  \"main\": \"src/index.ts\",\n  \"types\": \"src/index.ts\"\n}\n"
    },
    {
      "path": "packages/types/src/index.ts",
      "content": "export * from './journal';\n"
    },
    {
      "path": "packages/types/src/journal.ts",
      "content": "export type Mood = 'happy' | 'sad' | 'neutral' | 'excited' | 'anxious';\n\nexport interface IJournalEntry {\n  _id: string;\n  user: string; // User ID\n  content: string;\n  mood: Mood;\n  tags?: string[];\n  createdAt: string; // ISO Date String\n  updatedAt: string; // ISO Date String\n}\n"
    }
  ]
}
```
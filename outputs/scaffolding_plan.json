```json
{
  "repo_name": "lullaby-tales-app",
  "description": "A mobile application for generating personalized, calming bedtime stories using AI, designed to simplify the nightly routine for parents.",
  "files": [
    {
      "path": "README.md",
      "content": "# Lullaby Tales: Personalized Bedtime Stories App\n\n## Technical Blueprint\n\nThis document outlines the core technical architecture and technology stack for the Lullaby Tales application, a platform designed to create effortless, deeply personalized, and calming bedtime stories for children. The primary goal is to simplify the nightly routine for parents by leveraging AI to weave in specific details about their child's world. This detailed plan is intended to guide future execution, ensuring a robust and well-thought-out foundation.\n\n### 1. Strategic Goals & Technical Alignment\n\nEvery technical decision is made with the following strategic goals in mind, ensuring the solution directly addresses the market gap and core value proposition:\n\n*   **Effortless User Experience:** The app must be intuitive, requiring minimal creative effort from parents to input details and generate stories quickly. Technical choices prioritize smooth UI/UX, efficient backend processing, and intelligent defaults.\n*   **Deeply Personalized Stories:** The core value proposition relies on dynamic, rich personalization. This necessitates powerful AI/ML capabilities, a flexible data model for child profiles, and sophisticated prompt engineering to seamlessly integrate specific details.\n*   **Calming Bedtime Experience:** The narrative style, soothing voice options, and overall app flow must contribute to a relaxing atmosphere conducive to sleep. This requires careful selection and integration of Text-to-Speech (TTS) models and robust content safety mechanisms.\n*   **Simplifying Nightly Routine:** Fast story generation, easy access to saved preferences and past stories, and reliable performance are crucial to integrate seamlessly and effortlessly into a parent's evening routine.\n\n### 2. Recommended Technology Stack\n\nTo achieve the above goals, a modern, scalable, and AI-centric technology stack is recommended. Each choice is justified by its alignment with the project's strategic objectives.\n\n#### 2.1. Frontend (Mobile Application)\n\n*   **Technology:** React Native\n*   **Reasoning:**\n    *   **Cross-Platform Efficiency:** Allows a single codebase to target both iOS and Android, significantly accelerating development cycles and reducing maintenance overhead. This is vital for quickly reaching a broad audience as a startup.\n    *   **Rich UI/UX Capabilities:** Provides a robust set of components and excellent performance, enabling the creation of a fluid, intuitive, and visually appealing user interface essential for a calming and effortless experience.\n    *   **Extensive Ecosystem:** A large and active community, along with a vast array of libraries and tools, ensures that solutions for complex challenges (e.g., advanced audio playback, native module integration) are readily available.\n    *   **Developer Familiarity:** Broad developer availability for React-based technologies facilitates easier team scaling.\n*   **State Management:** Redux Toolkit (for predictable state management and complex data flows).\n*   **UI Library:** NativeBase or React Native Paper (for consistent, accessible, and performant UI components).\n\n#### 2.2. Backend (API & Business Logic)\n\n*   **Technology:** Python with FastAPI\n*   **Reasoning:**\n    *   **AI/ML Integration:** Python is the undisputed leader for AI, Machine Learning, and Natural Language Processing. This is paramount for the core story generation and personalization features, allowing seamless integration with libraries and services like OpenAI's API, Hugging Face models, and custom ML pipelines.\n    *   **High Performance:** FastAPI is a modern, asynchronous web framework known for its exceptional speed and low latency. Built on Starlette and Pydantic, it efficiently handles concurrent requests, crucial for real-time story generation and a responsive user experience.\n    *   **Developer Experience:** Auto-generated interactive API documentation (OpenAPI/Swagger UI) significantly simplifies frontend integration and future API evolution.\n    *   **Scalability:** Its lightweight nature and `async/await` support make it highly suitable for building scalable microservices, allowing independent scaling of different functional units.\n*   **Authentication:** JWT-based authentication (e.g., implemented using `python-jose` or integrated with managed services like Auth0/AWS Cognito).\n\n#### 2.3. Database\n\n*   **Technology:** PostgreSQL\n*   **Reasoning:**\n    *   **Robustness & Integrity:** A highly mature and reliable relational database, enforcing strong data consistency and integrity, which is crucial for storing sensitive user and child profile data, as well as story metadata.\n    *   **Flexibility with JSONB:** Its native `JSONB` support allows for flexible schema development, enabling storage of dynamic story parameters, child interests, and other semi-structured data points while retaining relational benefits like complex querying and strong consistency.\n    *   **Scalability & Reliability:** Proven scalability for diverse workloads and strong community support ensure long-term viability and ease of operation.\n\n#### 2.4. AI/ML Services & External APIs\n\n*   **Text Generation (LLM):** Utilizing powerful Large Language Models via API (e.g., OpenAI's GPT-4 series). This is the engine for deep personalization, dynamically crafting narratives based on intricate prompts. Future iterations may explore fine-tuning open-source models for specific child-friendly narrative styles or cost optimization.\n*   **Voice Synthesis (TTS):** Cloud-based Text-to-Speech services (e.g., Google Cloud Text-to-Speech, AWS Polly, Eleven Labs) offering a selection of high-quality, soothing voices. The quality and variety of voices are paramount for delivering a truly calming bedtime experience.\n*   **Content Safety/Moderation:** Integration with robust moderation APIs (e.g., OpenAI Moderation API) combined with custom rule-based filters. This is a critical component to ensure all generated story content is always age-appropriate, positive, and adheres to strict safety guidelines.\n\n### 3. Proposed Architecture Overview\n\nThe architecture is designed for high scalability, modularity, and maintainability. It leverages a microservices approach to enable independent development, deployment, and scaling of core functionalities, ensuring a seamless and reliable user experience.\n\n```mermaid\ngraph TD\n    A[Mobile Client (React Native)] -->|1. API Calls| B(API Gateway)\n\n    B --> C[User Management Service]\n    B --> D[Child Profile Service]\n    B --> E[Story Generation Service]\n    B --> F[Audio Synthesis Service]\n    B --> G[Content Safety Service]\n    B --> H[Payment Service]\n    B --> I[Analytics Service]\n\n    C --> K(PostgreSQL Database)\n    D --> K\n    H --> K\n\n    E --> L(2. AI Text Generation Model - LLM API)\n    E --> G\n    E --> P(Message Queue)\n\n    F --> M(3. TTS Model API)\n    F --> N(Object Storage - S3/GCS)\n\n    G -.-> L\n\n    P --> F\n\n    N --> A\n    K -.-> O[Caching (Redis)]\n\n    SubGraph Backend Services (FastAPI)\n        C\n        D\n        E\n        F\n        G\n        H\n        I\n    End\n```\n\n#### 3.1. Key Architectural Components:\n\n*   **Mobile Client (React Native App):** The primary user interface. Responsible for capturing parental input (child details, daily events, desired morals), initiating story generation requests, managing user subscriptions, and providing a smooth, integrated audio playback experience.\n*   **API Gateway:** Acts as the central entry point for all client requests, routing them to the appropriate backend service. It handles essential cross-cutting concerns like authentication, rate limiting, and SSL termination. (e.g., AWS API Gateway, Nginx).\n*   **Backend Services (Microservices with FastAPI):** Deployed as independent, stateless services, these encapsulate specific business logic and can scale individually.\n    *   **User Management Service:** Manages user authentication (registration, login, JWT issuance), user profiles, and subscription status.\n    *   **Child Profile Service:** Dedicated to managing child profiles, including names, ages, interests, favorite characters, friends, and historical data points provided by parents. This service is crucial for deep personalization.\n    *   **Story Generation Service:** The core intelligence of the application. It receives input from the mobile client and child profile data, intelligently constructs detailed prompts for the LLM, integrates all personalization elements into the narrative, applies moral/theme constraints, and invokes the Content Safety Service. It then dispatches the generated text to the Audio Synthesis Service, ideally via a message queue for asynchronous processing.\n    *   **Audio Synthesis Service:** Receives the generated story text. It then selects the appropriate soothing voice (based on user preference), calls the external TTS model API, stores the generated audio file (e.g., MP3) in object storage, and returns a secure, temporary URL for playback.\n    *   **Content Safety Service:** A critical, dedicated service that applies sophisticated filtering and moderation techniques (both pre- and post-LLM generation) to ensure all story content is age-appropriate, positive, and adheres to safety guidelines. This might involve keyword filtering, sentiment analysis, and integration with third-party moderation APIs.\n    *   **Payment Service:** Manages subscription plans, handles in-app purchases, and integrates with platform-specific billing systems (e.g., Apple In-App Purchases, Google Play Billing) and payment gateways (e.g., Stripe).\n    *   **Analytics Service:** Collects anonymized usage data, story generation metrics, engagement statistics, and user feedback to inform product improvements, personalization algorithm enhancements, and business decisions.\n*   **PostgreSQL Database:** The primary persistent data store. It houses all structured data, including user accounts, child profiles, saved stories, subscription information, and audit logs. Its robust nature ensures data integrity and supports complex queries for personalization.\n*   **Object Storage (AWS S3 / Google Cloud Storage):** Highly scalable, durable, and cost-effective storage for generated audio files, potentially story drafts, and any static assets (e.g., images for story covers). It enables efficient content delivery to the mobile client via CDN integration.\n*   **Caching (Redis):** Utilized for fast retrieval of frequently accessed data (e.g., user sessions, popular story themes, pre-computed results) to reduce database load and improve overall API responsiveness.\n*   **Message Queue (AWS SQS / Kafka):** Essential for enabling asynchronous communication between services. Long-running tasks like story generation and audio synthesis can be offloaded to the queue, preventing API timeouts and providing a more responsive user experience (e.g., allowing the app to show a \"generating story\" message while the backend processes).\n*   **CI/CD Pipeline (GitHub Actions / GitLab CI / AWS CodePipeline):** Automates the entire software delivery process, from code commit to deployment, ensuring rapid, consistent, and reliable updates across all environments.\n\n### 4. Key Workflows\n\n1.  **User Onboarding & Child Profile Creation:** Parents sign up, create their account, and then easily add child profiles, inputting details like name, age, interests, and friends. This data forms the basis for personalization.\n2.  **Story Request & Personalization Input:** A parent selects a child, provides dynamic inputs (e.g., \"what happened today?\", \"who did they play with?\", \"what moral lesson they learned?\"), and selects a preferred soothing voice option for the story.\n3.  **Story Generation Process (Asynchronous):**\n    *   The mobile app sends a story generation request to the Story Generation Service via the API Gateway.\n    *   The Story Generation Service retrieves relevant child details from the Child Profile Service and combines them with parental input to construct a detailed, personalized prompt.\n    *   This prompt is sent to the LLM API for narrative generation.\n    *   The generated story text is then passed through the Content Safety Service for moderation and filtering.\n    *   If the content is safe, the story text is published to the Message Queue, to be consumed asynchronously by the Audio Synthesis Service.\n    *   The Audio Synthesis Service picks up the text, generates audio via the TTS Model API, stores the audio file in Object Storage, and updates the Story Generation Service with the audio URL.\n    *   The Story Generation Service saves the complete story details (text, audio URL, parameters used) in the PostgreSQL database and notifies the mobile app of completion (e.g., via push notification or a polling mechanism).\n4.  **Story Playback:** Once notified, the mobile app retrieves the story details and streams the generated audio directly from the Object Storage, providing a calming listening experience.\n\n### 5. Future Considerations & Enhancements\n\n*   **Advanced Personalization Algorithms:** Implementing machine learning to analyze past story preferences and engagement to further refine personalization and narrative style over time.\n*   **Interactive Story Elements:** Introducing minor decision points within stories to enhance engagement for older children.\n*   **Multi-language & Accent Support:** Expanding the app's reach by offering stories in various languages and regional accents.\n*   **Parental Dashboard:** A feature-rich dashboard providing parents with insights into their children's story consumption, popular themes, and progress in learning morals.\n*   **Offline Mode:** Allowing parents to pre-download generated stories for playback without an internet connection, ideal for travel or areas with poor connectivity.\n*   **Content Licensing:** Exploring options for integrating licensed characters or themes into stories.\n\nThis blueprint provides a solid, detailed foundation for developing a scalable, secure, and deeply personalized bedtime story application, aligning directly with the strategic goals of effortlessness, deep personalization, and a calming experience. It ensures that every technical decision supports the core value proposition and unique selling points of Lullaby Tales."
    },
    {
      "path": ".env.example",
      "content": "DB_HOST=localhost\nDB_PORT=5432\nDB_USER=lullabytales\nDB_PASSWORD=password\nDB_NAME=lullabytales_db\n\nOPENAI_API_KEY=your_openai_api_key_here\nGOOGLE_CLOUD_TTS_API_KEY=your_google_cloud_tts_api_key_here # Or other TTS provider like ELEVEN_LABS_API_KEY\n\nJWT_SECRET_KEY=your_super_secret_jwt_key_for_auth\n\nAWS_S3_BUCKET_NAME=your-lullabytales-s3-bucket\nAWS_ACCESS_KEY_ID=your_aws_access_key_id\nAWS_SECRET_ACCESS_KEY=your_aws_secret_access_key\nAWS_REGION=your_aws_region\n\nSTRIPE_SECRET_KEY=sk_test_..."
    },
    {
      "path": "backend/requirements.txt",
      "content": "fastapi==0.111.0\nuvicorn[standard]==0.30.1\npsycopg2-binary==2.9.9\nsqlalchemy==2.0.30\npython-dotenv==1.0.1\nopenai==1.35.10\npython-jose[cryptography]==3.3.0\npydantic==2.8.2\naiohttp==3.9.5\naioboto3==12.0.0 # For S3 integration\npydub==0.25.1 # Optional: for basic audio processing if needed before storing\n"
    },
    {
      "path": "mobile/package.json",
      "content": "{\n  \"name\": \"LullabyTales\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"start\": \"expo start\",\n    \"android\": \"expo start --android\",\n    \"ios\": \"expo start --ios\",\n    \"web\": \"expo start --web\"\n  },\n  \"dependencies\": {\n    \"expo\": \"~51.0.17\",\n    \"expo-status-bar\": \"~1.12.1\",\n    \"react\": \"18.2.0\",\n    \"react-native\": \"0.74.2\",\n    \"react-native-safe-area-context\": \"4.10.1\",\n    \"react-native-screens\": \"3.31.1\",\n    \"@react-navigation/native\": \"^6.1.17\",\n    \"@react-navigation/stack\": \"^6.3.22\",\n    \"@reduxjs/toolkit\": \"^2.2.6\",\n    \"react-redux\": \"^9.1.2\",\n    \"@react-native-async-storage/async-storage\": \"1.23.1\",\n    \"react-native-sound\": \"^0.11.2\",\n    \"native-base\": \"^3.4.28\" \n  },\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.20.0\"\n  }\n}\n"
    },
    {
      "path": "backend/app/main.py",
      "content": "# Basic FastAPI Application Structure\n\nfrom fastapi import FastAPI, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom sqlalchemy.orm import Session\nfrom typing import Annotated\nimport os\n\n# Placeholder for database, models, and schemas (to be implemented in separate files)\n# from . import models, schemas, crud\n# from .database import SessionLocal, engine\n\n# Uncomment the following lines if you want to create tables on app startup (for dev/testing)\n# models.Base.metadata.create_all(bind=engine)\n\napp = FastAPI(\n    title=\"Lullaby Tales API\",\n    description=\"API for generating personalized bedtime stories.\",\n    version=\"0.1.0\"\n)\n\n# Dependency to get DB session (placeholder for actual DB connection)\n# def get_db():\n#     db = SessionLocal()\n#     try:\n#         yield db\n#     finally:\n#         db.close()\n\n# Placeholder for OAuth2 for user authentication\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n# Dummy function for current user (to be replaced with actual JWT decoding and validation)\nasync def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):\n    # In a real application, this would decode the JWT, verify its signature, expiration,\n    # and then potentially fetch user details from the database.\n    if token != \"dummy_token\": # Placeholder check\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid authentication credentials\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    # Return a dummy user payload for demonstration\n    return {\"username\": \"testuser\", \"id\": 1, \"email\": \"test@example.com\"}\n\n@app.get(\"/\", tags=[\"Health Check\"])\nasync def read_root():\n    return {\"message\": \"Welcome to Lullaby Tales API!\"}\n\n@app.get(\"/users/me/\", tags=[\"User Management\"])\nasync def read_users_me(current_user: Annotated[dict, Depends(get_current_user)]):\n    return current_user\n\n@app.post(\"/stories/generate\", tags=[\"Story Generation\"])\nasync def generate_story(\n    child_id: int,\n    prompt_details: dict, # Expected keys: daily_event, friend_name, moral, etc.\n    user: Annotated[dict, Depends(get_current_user)]\n): \n    # --- Real Story Generation Logic (Conceptual Steps) ---\n    # 1. Authenticate and authorize the user, ensure child_id belongs to the user.\n    # 2. Retrieve detailed child information from the Child Profile Service (DB).\n    #    child_info = crud.get_child(db, child_id=child_id, user_id=user['id'])\n    # 3. Construct a sophisticated prompt for the LLM based on child_info and prompt_details.\n    #    e.g., \"Create a calming bedtime story for {child_name} who {daily_event}. Include {friend_name} and teach about {moral}.\"\n    # 4. Call the LLM API (e.g., OpenAI.chat.completions.create).\n    #    llm_response = openai.chat.completions.create(model=\"gpt-4o-mini\", messages=[...])\n    #    generated_text = llm_response.choices[0].message.content\n    # 5. Pass generated_text through the Content Safety Service for moderation.\n    #    is_safe = content_safety_service.moderate_text(generated_text)\n    #    if not is_safe: raise HTTPException(status_code=400, detail=\"Story content deemed unsafe.\")\n    # 6. Send the safe text to the Audio Synthesis Service (ideally via a message queue like SQS).\n    #    audio_url = await audio_synthesis_service.synthesize_and_store(generated_text, preferred_voice_id)\n    # 7. Store the complete story details (text, audio URL, generation parameters) in the PostgreSQL DB.\n    #    crud.create_story(db, user_id=user['id'], child_id=child_id, text=generated_text, audio_url=audio_url, params=prompt_details)\n    # 8. Return a confirmation and temporary audio URL.\n\n    # --- Dummy Implementation for Demonstration ---\n    print(f\"User {user['id']} generating story for child {child_id} with details: {prompt_details}\")\n    child_name = prompt_details.get('child_name', 'a little adventurer')\n    daily_event = prompt_details.get('daily_event', 'had a lovely day')\n    friend_name = prompt_details.get('friend_name', 'their friend')\n    moral = prompt_details.get('moral', 'the importance of kindness')\n\n    generated_text = (\n        f\"Once upon a time, in a cozy little town, lived {child_name} who {daily_event}. \"\n        f\"Today, {child_name} played with {friend_name}, and together they learned about {moral}. \"\n        \"As the stars twinkled, {child_name} snuggled into bed, dreaming sweet dreams filled with friendship and happy memories. Good night!\"\n    )\n    # Simulate a temporary audio URL from a TTS service\n    audio_url = \"https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3\" # Placeholder MP3 URL\n    \n    return {\"status\": \"success\", \"message\": \"Story generation initiated.\", \"story_text\": generated_text, \"audio_url\": audio_url}\n\n# --- Additional Endpoints to be implemented ---\n# @app.post(\"/register\")\n# @app.post(\"/token\") # For JWT login\n# @app.post(\"/children/\")\n# @app.get(\"/children/{child_id}\")\n# @app.get(\"/stories/\") # Get user's past stories\n# @app.get(\"/stories/{story_id}\")\n# @app.post(\"/webhooks/stripe\") # For subscription management\n"
    },
    {
      "path": "mobile/App.js",
      "content": "import { StatusBar } from 'expo-status-bar';\nimport { StyleSheet, Text, View, Button, TextInput, ActivityIndicator, Alert, ScrollView } from 'react-native';\nimport React, { useState, useEffect, useRef } from 'react';\nimport { NavigationContainer } from '@react-navigation/native';\nimport { createStackNavigator } from '@react-navigation/stack';\nimport { Provider } from 'react-redux';\nimport { configureStore, createSlice } from '@reduxjs/toolkit';\nimport Sound from 'react-native-sound';\n\n// --- Redux Setup (Simplified for demonstration) ---\nconst storySlice = createSlice({\n  name: 'story',\n  initialState: {\n    currentStory: null,\n    isLoading: false,\n    error: null,\n    childProfiles: [\n        { id: 1, name: 'Lily', interests: 'unicorns, space' },\n        { id: 2, name: 'Max', interests: 'dinosaurs, cars' }\n    ] // Dummy child profiles\n  },\n  reducers: {\n    fetchStoryStart: (state) => {\n      state.isLoading = true;\n      state.error = null;\n      state.currentStory = null;\n    },\n    fetchStorySuccess: (state, action) => {\n      state.isLoading = false;\n      state.currentStory = action.payload;\n    },\n    fetchStoryFailure: (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload;\n    },\n  },\n});\n\nexport const { fetchStoryStart, fetchStorySuccess, fetchStoryFailure } = storySlice.actions;\n\nconst store = configureStore({\n  reducer: {\n    story: storySlice.reducer,\n  },\n});\n\n// --- Story Generation Screen ---\nfunction StoryGenerationScreen({ navigation }) {\n  const [childId, setChildId] = useState('1'); \n  const [dailyEvent, setDailyEvent] = useState('');\n  const [friendName, setFriendName] = useState('');\n  const [moral, setMoral] = useState('');\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState('');\n\n  const handleGenerateStory = async () => {\n    if (!dailyEvent.trim() || !moral.trim()) {\n      Alert.alert(\"Missing Details\", \"Please provide a daily event and desired moral for the story.\");\n      return;\n    }\n\n    setLoading(true);\n    setError('');\n    try {\n      const child = store.getState().story.childProfiles.find(c => c.id === parseInt(childId));\n      if (!child) {\n        setError(\"Child not found.\");\n        setLoading(false);\n        return;\n      }\n\n      const response = await fetch('http://localhost:8000/stories/generate', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': 'Bearer dummy_token' // IMPORTANT: Replace with actual JWT from login\n        },\n        body: JSON.stringify({\n          child_id: parseInt(childId),\n          prompt_details: {\n            child_name: child.name,\n            daily_event: dailyEvent.trim(),\n            friend_name: friendName.trim(),\n            moral: moral.trim(),\n          },\n        }),\n      });\n\n      const data = await response.json();\n\n      if (response.ok) {\n        navigation.navigate('StoryDisplay', { storyText: data.story_text, audioUrl: data.audio_url });\n      } else {\n        setError(data.detail || 'Failed to generate story. Please try again.');\n      }\n    } catch (err) {\n      setError('Network error or server unavailable. Please check your connection.');\n      console.error(\"API Call Error:\", err);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <ScrollView contentContainerStyle={styles.container}>\n      <Text style={styles.title}>Create Your Personalized Bedtime Story</Text>\n      <Text style={styles.label}>Child Name:</Text>\n      <TextInput\n        style={styles.input}\n        value={store.getState().story.childProfiles.find(c => c.id === parseInt(childId))?.name || 'Select Child'}\n        editable={false}\n      />\n      <Text style={styles.label}>What happened today? (e.g., \"went to the park\")</Text>\n      <TextInput\n        style={styles.input}\n        onChangeText={setDailyEvent}\n        value={dailyEvent}\n        placeholder=\"e.g., played with blocks at daycare\" \n        multiline\n      />\n      <Text style={styles.label}>Who did they play with? (optional)</Text>\n      <TextInput\n        style={styles.input}\n        onChangeText={setFriendName}\n        value={friendName}\n        placeholder=\"e.g., their friend Maya\"\n      />\n      <Text style={styles.label}>Desired moral for the story (e.g., \"sharing is caring\"):</Text>\n      <TextInput\n        style={styles.input}\n        onChangeText={setMoral}\n        value={moral}\n        placeholder=\"e.g., always be kind\"\n        multiline\n      />\n      <Button title={loading ? \"Generating Story...\" : \"Generate Story\"} onPress={handleGenerateStory} disabled={loading} />\n      {loading && <ActivityIndicator size=\"large\" color=\"#0000ff\" style={styles.activityIndicator} />}\n      {error ? <Text style={styles.errorText}>{error}</Text> : null}\n      <StatusBar style=\"auto\" />\n    </ScrollView>\n  );\n}\n\n// --- Story Display Screen ---\nfunction StoryDisplayScreen({ route }) {\n  const { storyText, audioUrl } = route.params;\n  const [isPlaying, setIsPlaying] = useState(false);\n  const soundRef = useRef(null);\n\n  useEffect(() => {\n    Sound.setCategory('Playback');\n    if (audioUrl) {\n      const newSound = new Sound(audioUrl, null, (error) => {\n        if (error) {\n          console.log('Failed to load the sound', error);\n          Alert.alert(\"Audio Error\", \"Could not load story audio. Please try again.\");\n          return;\n        }\n        soundRef.current = newSound;\n      });\n    }\n\n    return () => {\n      if (soundRef.current) {\n        soundRef.current.release();\n        soundRef.current = null;\n      }\n    };\n  }, [audioUrl]);\n\n  const playStopSound = () => {\n    if (!soundRef.current) {\n      Alert.alert(\"Audio Not Ready\", \"Audio is still loading or unavailable. Please wait or try again.\");\n      return;\n    }\n\n    if (isPlaying) {\n      soundRef.current.pause(() => {\n        console.log('Playback paused');\n        setIsPlaying(false);\n      });\n    } else {\n      soundRef.current.play((success) => {\n        if (success) {\n          console.log('Successfully finished playing');\n        } else {\n          console.log('Playback failed:', soundRef.current.getError());\n          Alert.alert(\"Playback Error\", \"Failed to play audio. Please try again.\");\n        }\n        setIsPlaying(false);\n      });\n      setIsPlaying(true);\n    }\n  };\n\n  return (\n    <ScrollView contentContainerStyle={styles.container}>\n      <Text style={styles.title}>Your Personalized Bedtime Story</Text>\n      <Text style={styles.storyText}>{storyText}</Text>\n      {audioUrl ? (\n        <View style={styles.audioControls}>\n          <Button title={isPlaying ? \"Pause Audio\" : \"Play Audio\"} onPress={playStopSound} />\n        </View>\n      ) : (\n        <Text style={styles.noAudioText}>No audio available for this story.</Text>\n      )}\n      <StatusBar style=\"auto\" />\n    </ScrollView>\n  );\n}\n\n// --- Navigation Setup ---\nconst Stack = createStackNavigator();\n\nexport default function App() {\n  return (\n    <Provider store={store}>\n      <NavigationContainer>\n        <Stack.Navigator initialRouteName=\"StoryGeneration\">\n          <Stack.Screen name=\"StoryGeneration\" component={StoryGenerationScreen} options={{ title: 'Create Bedtime Story' }} />\n          <Stack.Screen name=\"StoryDisplay\" component={StoryDisplayScreen} options={{ title: 'Your Story' }} />\n        </Stack.Navigator>\n      </NavigationContainer>\n    </Provider>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n    backgroundColor: '#f5f5f5',\n    alignItems: 'center',\n    padding: 20,\n  },\n  title: {\n    fontSize: 24,\n    fontWeight: 'bold',\n    marginBottom: 20,\n    textAlign: 'center',\n    color: '#333',\n  },\n  label: {\n    fontSize: 16,\n    marginBottom: 5,\n    alignSelf: 'flex-start',\n    marginLeft: '5%',\n    width: '90%'\n  },\n  input: {\n    borderWidth: 1,\n    borderColor: '#ddd',\n    borderRadius: 8,\n    padding: 12,\n    marginBottom: 15,\n    width: '90%',\n    backgroundColor: '#fff',\n    fontSize: 16,\n    minHeight: 40,\n  },\n  storyText: {\n    fontSize: 18,\n    lineHeight: 28,\n    textAlign: 'justify',\n    marginBottom: 20,\n    paddingHorizontal: 10,\n    color: '#555',\n  },\n  audioControls: {\n    marginTop: 20,\n    marginBottom: 20,\n  },\n  errorText: {\n    color: 'red',\n    marginTop: 10,\n    textAlign: 'center',\n  },\n  activityIndicator: {\n    marginTop: 20,\n  },\n  noAudioText: {\n    marginTop: 20,\n    fontStyle: 'italic',\n    color: '#888',\n  }\n});\n"
    },
    {
      "path": "backend/app/database.py",
      "content": "import os\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\n\n# Load environment variables for database connection\nfrom dotenv import load_dotenv\nload_dotenv()\n\n# Database connection details from environment variables\nDB_HOST = os.getenv(\"DB_HOST\", \"localhost\")\nDB_PORT = os.getenv(\"DB_PORT\", \"5432\")\nDB_USER = os.getenv(\"DB_USER\", \"lullabytales\")\nDB_PASSWORD = os.getenv(\"DB_PASSWORD\", \"password\")\nDB_NAME = os.getenv(\"DB_NAME\", \"lullabytales_db\")\n\n# Construct the PostgreSQL connection URL\n# Example: postgresql://user:password@host:port/dbname\nSQLALCHEMY_DATABASE_URL = f\"postgresql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}\"\n\n# Create the SQLAlchemy engine\n# echo=True will log all SQL statements, useful for debugging\nengine = create_engine(\n    SQLALCHEMY_DATABASE_URL, \n    pool_pre_ping=True # Ensures connections are still alive\n)\n\n# Create a SessionLocal class to get a database session\n# autocommit=False ensures transactions are managed manually (commit/rollback)\n# autoflush=False prevents flushing pending changes before a commit\nsession_local = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n# Base class for SQLAlchemy declarative models\nBase = declarative_base()\n\n# Dependency for FastAPI routes to get a database session\ndef get_db():\n    db = session_local()\n    try:\n        yield db\n    finally:\n        db.close()\n"
    },
    {
      "path": "backend/app/models.py",
      "content": "from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Text, JSON, Boolean\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql import func\n\nfrom .database import Base\n\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String, unique=True, index=True, nullable=False)\n    hashed_password = Column(String, nullable=False)\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now())\n\n    children = relationship(\"Child\", back_populates=\"parent\", cascade=\"all, delete-orphan\")\n    stories = relationship(\"Story\", back_populates=\"user\", cascade=\"all, delete-orphan\")\n\n    def __repr__(self):\n        return f\"<User(id={self.id}, email='{self.email}')>\"\n\nclass Child(Base):\n    __tablename__ = \"children\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    parent_id = Column(Integer, ForeignKey(\"users.id\", ondelete=\"CASCADE\"), nullable=False)\n    name = Column(String, nullable=False)\n    age = Column(Integer) # Optional age for age-appropriate content\n    gender = Column(String) # Optional: for pronoun usage in stories\n    interests = Column(JSON) # Store as JSON list (e.g., [\"unicorns\", \"space\", \"dinosaurs\"])\n    friends = Column(JSON)   # Store as JSON list (e.g., [\"Leo\", \"Maya\"])\n    favorite_characters = Column(JSON) # e.g., [\"brave knight\", \"talking dog\"]\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now())\n\n    parent = relationship(\"User\", back_populates=\"children\")\n    stories = relationship(\"Story\", back_populates=\"child\", cascade=\"all, delete-orphan\")\n\n    def __repr__(self):\n        return f\"<Child(id={self.id}, name='{self.name}', parent_id={self.parent_id})>\"\n\nclass Story(Base):\n    __tablename__ = \"stories\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    user_id = Column(Integer, ForeignKey(\"users.id\", ondelete=\"CASCADE\"), nullable=False)\n    child_id = Column(Integer, ForeignKey(\"children.id\", ondelete=\"CASCADE\"), nullable=False)\n    title = Column(String, index=True)\n    story_text = Column(Text, nullable=False)\n    audio_url = Column(String) # URL to the generated audio file in object storage\n    prompt_parameters_used = Column(JSON) # Store the exact personalized inputs and LLM prompt details for reproducibility/debugging\n    is_safe = Column(Boolean, default=True) # Flag indicating content safety check result\n    word_count = Column(Integer) # Optional: for analytics/story length control\n    duration_seconds = Column(Integer) # Optional: estimated audio duration\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n\n    user = relationship(\"User\", back_populates=\"stories\")\n    child = relationship(\"Child\", back_populates=\"stories\")\n\n    def __repr__(self):\n        return f\"<Story(id={self.id}, title='{self.title}', user_id={self.user_id}, child_id={self.child_id})>\"\n"
    }
  ]
}
```